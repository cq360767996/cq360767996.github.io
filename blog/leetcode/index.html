<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>记录力扣日常 | Recovery</title>
    <meta name="description" content="记录自己的力扣之旅">
    <link rel="stylesheet" href="/assets/style.07fe701b.css">
    <link rel="modulepreload" href="/assets/blog_css_居中方案.md.29424092.js">
    <link rel="modulepreload" href="/assets/blog_interview_index.md.45c364a7.js">
    <link rel="modulepreload" href="/assets/blog_js_js模块化.md.b0117550.js">
    <link rel="modulepreload" href="/assets/blog_js_代码规范.md.c7f00b1b.js">
    <link rel="modulepreload" href="/assets/blog_js_前端性能优化.md.52cf8bde.js">
    <link rel="modulepreload" href="/assets/blog_js_手写promise.md.4beada86.js">
    <link rel="modulepreload" href="/assets/blog_js_手写系列.md.a709f2a6.js">
    <link rel="modulepreload" href="/assets/blog_js_浏览器常见问题.md.8ba8df15.js">
    <link rel="modulepreload" href="/assets/blog_js_闭包详解.md.4058efc9.js">
    <link rel="modulepreload" href="/assets/blog_leetcode_index.md.b587bdc7.js">
    <link rel="modulepreload" href="/assets/blog_ts_index.md.b0a695eb.js">
    <link rel="modulepreload" href="/assets/blog_vue_基于el-tree的虚拟滚动.md.03e1560f.js">
    <link rel="modulepreload" href="/assets/blog_webpack_webpack优化.md.70600524.js">
    <link rel="modulepreload" href="/assets/app.853852ae.js">
    <link rel="modulepreload" href="/assets/blog_leetcode_index.md.b587bdc7.lean.js">
    
    <link rel="icon" href="/icon.svg">
  <link rel="stylesheet" href="//fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&amp;family=Dosis:wght@300;400;500;600;700&amp;display=swap">
  <meta name="twitter:title" content="记录力扣日常 | Recovery">
  <meta property="og:title" content="记录力扣日常 | Recovery">
  </head>
  <body>
    <div id="app"><!--[--><div class="bg-gray-50 px-5 sm:px-7 md:px-10"><div class="prose md:prose-xl prose-green mx-auto"><header class="navbar mb-10 sm:mb-16 md:mb-20"><div class="w-full flex items-center justify-between border-b-2 border-gray-100 py-3 md:py-6"><div class="relative ml-2 md:ml-0"><svg class="absolute -left-25px -top-14px z-0 transform rotate-45 opacity-20" viewBox="0 0 200 200" width="80" height="80" xmlns="http://www.w3.org/2000/svg"><path fill="#059669" d="M50.4,-15.8C59.3,10.9,56.2,42.1,36,58.9C15.9,75.8,-21.4,78.3,-41.8,62.4C-62.2,46.4,-65.8,11.9,-56,-16C-46.2,-43.9,-23.1,-65.4,-1.2,-65C20.8,-64.6,41.5,-42.4,50.4,-15.8Z" transform="translate(100 100)"></path></svg><a class="relative text-3xl text-green-600 z-1" aria-label="Recovery, back to home" href="/"><span class="font-bold font-header text-green-700">Recovery</span></a></div><div class="flex-grow"></div><!--[--><nav class="flex items-center list-none transform translate-y-0.25"><div class="hidden md:block"><!--[--><div class="nav-item inline-block ml-8" data-v-2dfda6e2><a class="nav-link font-semibold text-gray-700 d-block" href="/" target="" rel="" data-v-2dfda6e2>Home</a></div><div class="nav-item inline-block ml-8" data-v-2dfda6e2><a class="nav-link font-semibold text-gray-700 d-block" href="/about/" target="" rel="" data-v-2dfda6e2>About</a></div><div class="nav-item inline-block ml-8" data-v-2dfda6e2><a class="nav-link font-semibold text-gray-700 d-block" href="/contact/" target="" rel="" data-v-2dfda6e2>Contact</a></div><!--]--></div><div class="-mr-2 -my-2 md:hidden"><button type="button" class="bg-white rounded-md p-2 inline-flex items-center justify-center text-gray-400 hover:text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-green-500"><span class="sr-only">Open menu</span><svg class="h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></nav><div class="opacity-0 scale-95 duration-100 ease-in pointer-events-none absolute z-10 top-0 inset-x-0 p-2 transition transform origin-top-right md:hidden"><div class="rounded-lg shadow-lg ring-1 ring-black ring-opacity-5 bg-white divide-y-2 divide-gray-50"><div class="pt-5 pb-6 px-5"><button type="button" class="absolute z-20 top-4 right-4 bg-white rounded-md p-2 inline-flex items-center justify-center text-gray-400 hover:text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-green-500"><span class="sr-only">Close menu</span><svg class="h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button><div class="text-center"><!--[--><div class="nav-item mb-2" data-v-2dfda6e2><a class="nav-link font-semibold text-gray-700 d-block" href="/" target="" rel="" data-v-2dfda6e2>Home</a></div><div class="nav-item mb-2" data-v-2dfda6e2><a class="nav-link font-semibold text-gray-700 d-block" href="/about/" target="" rel="" data-v-2dfda6e2>About</a></div><div class="nav-item mb-2" data-v-2dfda6e2><a class="nav-link font-semibold text-gray-700 d-block" href="/contact/" target="" rel="" data-v-2dfda6e2>Contact</a></div><!--]--></div></div></div></div><!--]--><div class="algolia-search-box" id="docsearch"></div></div></header><main class="pb-10 sm:pb-16 md:pb-20"><!----><div style="position:relative;" class="content animate-fadeIn"><div><h2 id="easy" tabindex="-1">easy <a class="header-anchor" href="#easy" aria-hidden="true">#</a></h2><h3 id="罗马文字解析" tabindex="-1">罗马文字解析 <a class="header-anchor" href="#罗马文字解析" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener noreferrer">地址</a></p><blockquote><p>当前数字小于后一个的值时，后一个值减去前一个值，i++</p></blockquote><div class="language-js"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">&lt;</span> map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  val <span class="token operator">=</span> map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> val<span class="token punctuation">;</span>
  i<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="最长公共前缀" tabindex="-1">最长公共前缀 <a class="header-anchor" href="#最长公共前缀" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/solution/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>先遍历一次拿长度最短的</li><li>再遍历比较遇到值不对的直接跳出，并截取公共串</li></ul><div class="language-js"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span>demo<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!==</span> str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  demo <span class="token operator">=</span> demo<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>更好的思路</p><ul><li>取第一个为参照</li><li>依次去对比所有项中对应的字符</li><li>遇到不同退出循环，记录第一个参照此时的索引</li></ul><div class="language-js"><pre><code><span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nowChar <span class="token operator">!==</span> strs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  j<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="有效的括号" tabindex="-1">有效的括号 <a class="header-anchor" href="#有效的括号" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener noreferrer">地址</a></p><blockquote><p>优化思路，这种找对应关系的题目，可以通过取余来判断</p></blockquote><div class="language-js"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="合并两个有序链表" tabindex="-1">合并两个有序链表 <a class="header-anchor" href="#合并两个有序链表" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener noreferrer">地址</a></p><p>思路一：</p><ul><li>用一个结果链表装载结果</li><li>每次移动 l1/l2 中的较小值的那个指针</li><li>将结果指针指向较小值的那个节点</li><li>后移较小值的指针和结果链表的指针</li></ul><div class="language-js"><pre><code><span class="token keyword">var</span> <span class="token function-variable function">mergeTwoLists</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">l1<span class="token punctuation">,</span> l2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> prevHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> prevNode <span class="token operator">=</span> prevHead<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">&amp;&amp;</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      prevNode<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>
      l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      prevNode<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>
      l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    prevNode <span class="token operator">=</span> prevNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  prevNode<span class="token punctuation">.</span>next <span class="token operator">=</span> l1 <span class="token operator">||</span> l2<span class="token punctuation">;</span>
  <span class="token keyword">return</span> prevHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>思路二：</p><ul><li>将结果集由 l1/l2 输出</li><li>通过移动 l1/l2 的指针不断递归</li></ul><div class="language-js"><pre><code><span class="token keyword">var</span> <span class="token function-variable function">mergeTwoLists</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">l1<span class="token punctuation">,</span> l2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>l1<span class="token punctuation">)</span> <span class="token keyword">return</span> l2<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>l2<span class="token punctuation">)</span> <span class="token keyword">return</span> l1<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    l1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> l1<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    l2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> l2<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="删除有序数组中的重复项" tabindex="-1">删除有序数组中的重复项 <a class="header-anchor" href="#删除有序数组中的重复项" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener noreferrer">地址</a></p><blockquote><ol><li>不能使用额外空间</li><li>不需要处理之后的元素</li></ol></blockquote><ul><li>用两个指针，<code>i=1</code>、<code>j=0</code>，<code>i</code>是遍历的指针，<code>j</code>是输出集的指针</li><li><code>nums[i] !== nums[i - 1]</code>，<code>j++</code>，并且<code>nums[j] = nums[i]</code></li></ul><div class="language-js"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  j<span class="token operator">++</span><span class="token punctuation">;</span>
  nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
i<span class="token operator">++</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="实现-strstr" tabindex="-1">实现 strStr() <a class="header-anchor" href="#实现-strstr" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/implement-strstr/solution/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>比较长度，仅在前者长度大于后者进行遍历</li><li>遍历长度为<code>len1 - len2 + 1</code></li><li>不相等直接退出内部循环</li></ul><div class="language-js"><pre><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> diff <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> equal <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>haystack<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">!==</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        equal <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>equal<span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>
</code></pre></div><h3 id="外观数列" tabindex="-1">外观数列 <a class="header-anchor" href="#外观数列" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/count-and-say/" target="_blank" rel="noopener noreferrer">地址</a></p><p>思路一：正则表达式</p><div class="language-js"><pre><code>start <span class="token operator">=</span> start<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\d)\1*</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token parameter">matcher</span> <span class="token operator">=&gt;</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>matcher<span class="token punctuation">.</span>length<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>matcher<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="最大子序和" tabindex="-1">最大子序和 <a class="header-anchor" href="#最大子序和" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener noreferrer">地址</a></p><p>思路一：动态规划</p><div class="language-js"><pre><code><span class="token comment">// 转移方程</span>
<span class="token function">f</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol><li>前 i 项的最大值 = 前 i-1 项最大值 + 第 i 项 和 第 i 项的最大值</li><li>保留每次计算的前 i 项的和和前 i 项的最大值</li><li>取其中的最大值</li></ol><h3 id="最后一个单词的长度" tabindex="-1">最后一个单词的长度 <a class="header-anchor" href="#最后一个单词的长度" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener noreferrer">地址</a></p><p>思路从右往左遍历，先去除所有空格，再计算长度，再次遇到空格或者 i=0 输出结果</p><h3 id="x-的平方根" tabindex="-1">x 的平方根 <a class="header-anchor" href="#x-的平方根" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener noreferrer">地址</a></p><p>二分查找,对比<code>mid * mid</code>和<code>x</code>的大小，<code>mid * mid &lt; x</code></p><h3 id="合并两个有序数组" tabindex="-1">合并两个有序数组 <a class="header-anchor" href="#合并两个有序数组" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener noreferrer">地址</a></p><p>双指针法 从前往后遍历需要额外的空间 时间复杂度：O(m+n) 空间复杂度：O(m+n)</p><p>优化思路 从后往前遍历，因为后面都是 0，不会出现覆盖的问题 时间复杂度：O(m+n) 空间复杂度：O(1)</p><h3 id="只出现一次的数字" tabindex="-1">只出现一次的数字 <a class="header-anchor" href="#只出现一次的数字" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener noreferrer">地址</a></p><p>使用异或运算符<code>^</code>，具备以下特点</p><ul><li><code>a ^ 0 === a</code></li><li><code>a ^ a === 0</code></li><li><code>a ^ b ^ a === b</code></li></ul><h3 id="相交链表" tabindex="-1">相交链表 <a class="header-anchor" href="#相交链表" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener noreferrer">地址</a></p><p>双指针法</p><div class="language-"><pre><code>p1: headA =&gt; headA End =&gt; headB =&gt; node
p2: headB =&gt; headB End =&gt; headA =&gt; node
如果相交的话，则满足：
a + (b - c) = b + (a - c)
</code></pre></div><h3 id="多数元素" tabindex="-1">多数元素 <a class="header-anchor" href="#多数元素" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/majority-element/description/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li><p>思路一：hash table 时间复杂度：O(n) 空间复杂度：O(n)</p></li><li><p>思路二：打分法 遍历，然后给每一个元素打分，等于 candidate 记为 1，不等于记为-1，<code>count===0</code>表示需要变更<code>candidate</code> 核心思想就是多数是大于<code>n / 2</code>，所以通过消除法，最后剩余的肯定是最多的数</p></li></ul><h3 id="阶乘后的零" tabindex="-1">阶乘后的零 <a class="header-anchor" href="#阶乘后的零" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noopener noreferrer">地址</a></p><p>规律就是</p><ul><li>每隔 5 个数出现一次 0，所以总数应该是 n / 5</li><li>但是每隔 25 个数又会额外多处一个 1 一个 0</li><li>每隔 625 个数又会额外多处一个 0</li><li>以此类推</li><li>总数 = n / 5 + n / 25 + n / 625 +++</li></ul><h3 id="颠倒二进制位" tabindex="-1">颠倒二进制位 <a class="header-anchor" href="#颠倒二进制位" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener noreferrer">地址</a></p><p>位运算符笔记</p><ul><li>&gt;&gt; 右移运算符，正数高位补 0，负数高位补 1 <code>111</code> =&gt; <code>11</code> <code>-111</code> =&gt; <code>11111111111111111111111111111100</code></li><li>&lt;&lt; 左移运算符，低位补 0 <code>111</code> =&gt; <code>1110</code></li><li>&gt;&gt;&gt; 无符号右移，高位补 0 <code>-111</code> =&gt; <code>11111111111111111111111111111000</code> =&gt; <code>01111111111111111111111111111100</code></li></ul><ol><li>JavaScript 中数字存储格式是 64 位浮点数</li><li>JavaScript 中进行位运算的数字格式是 32 位二进制数</li><li>负数的二进制写法是正数的二进制补码+1</li><li>这种长位数作运算的时候会用 16 进制来表示，即四位变成一位，用 0x 作开头</li><li>toString(2)可以将十进制转换成二进制，带正负号。。</li></ol><p>无符号右移 0 作用 <a href="https://www.jianshu.com/p/588eb74b5a03" target="_blank" rel="noopener noreferrer">地址</a></p><h3 id="快乐数" tabindex="-1">快乐数 <a class="header-anchor" href="#快乐数" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/happy-number/description/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>思路一：哈希表，缓存所有值</li><li>思路二：可以理解为一个循环指针</li></ul><h3 id="计算质数" tabindex="-1">计算质数 <a class="header-anchor" href="#计算质数" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>思路一：暴力法</li><li>思路二：依此遍历，如果 i 是质数，则 i 的 x 倍是合数，缓存结果减少计算</li></ul><h3 id="反转链表" tabindex="-1">反转链表 <a class="header-anchor" href="#反转链表" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>思路一：迭代</li><li>思路二：递归，归的过程需要反转两个链表<code>head.next.next = head; head.next = null;</code></li></ul><h3 id="汇总区间" tabindex="-1">汇总区间 <a class="header-anchor" href="#汇总区间" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/summary-ranges/" target="_blank" rel="noopener noreferrer">地址</a></p><p>读清楚题目，要求是连续就收起来，不连续就单独放 <code>0 1 2 4 5 7</code><code>0 1 2</code>连续 =&gt; <code>0-&gt;2</code><code>4 5</code> 连续 =&gt; <code>4-&gt;5</code><code>7</code> =&gt; <code>7</code></p><h3 id="_2-的幂" tabindex="-1">2 的幂 <a class="header-anchor" href="#_2-的幂" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener noreferrer">地址</a></p><p>2 的幂满足二进制表示的时候只有一个 1，且在最高位 所以可以判断<code>n &amp; (n - 1)</code>是否等于 0 来求解</p><h3 id="回文链表" tabindex="-1">回文链表 <a class="header-anchor" href="#回文链表" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>思路一：转为数组，然后循环判断是否回文</li><li>思路二：快慢指针，找到中点并且反转前半部分 =&gt; 对比反转链表和剩余链表的值</li></ul><h3 id="二叉搜索树的最近公共祖先" tabindex="-1">二叉搜索树的最近公共祖先 <a class="header-anchor" href="#二叉搜索树的最近公共祖先" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>思路一：先找到 p 和 q 节点的路径，再对比找到最后一个相等的节点就是高度最低的节点</li><li>思路二：如果 p 和 q 都当前节点小，<code>node = node.left</code>，如果都比当前节点大<code>node = node.right</code>，找到介于两者之间的值就是结果</li><li>思路三：递归实现思路二</li></ul><h3 id="各数相加" tabindex="-1">各数相加 <a class="header-anchor" href="#各数相加" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/add-digits/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>思路一：循环+递归</li><li>思路二：可以理解为除以 9 的余数</li></ul><h3 id="丑数" tabindex="-1">丑数 <a class="header-anchor" href="#丑数" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/ugly-number/" target="_blank" rel="noopener noreferrer">地址</a></p><ol><li>丑数大于 0</li><li>丑数只能被 2、3、5 整除</li><li>1 被视为丑数</li></ol><h3 id="丢失的数字" tabindex="-1">丢失的数字 <a class="header-anchor" href="#丢失的数字" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/missing-number/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>思路一：排序，然后对比下标和值</li><li>思路二：异或运算</li><li>思路三：求<code>0-n</code>的和，减去所有值的和就是结果</li></ul><div class="language-"><pre><code>0 ^ 0 ^ 1 ^ 1 ^ 2 ^ 3 ^ 3 =&gt; 2
</code></pre></div><h3 id="第一个错误的版本" tabindex="-1">第一个错误的版本 <a class="header-anchor" href="#第一个错误的版本" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener noreferrer">地址</a></p><p>二分求中位数</p><div class="language-js"><pre><code><span class="token keyword">const</span> mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>start <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="移动零" tabindex="-1">移动零 <a class="header-anchor" href="#移动零" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>思路一：计数器，遇到 0 就<code>counter++</code>，非 0 就<code>nums[i - couter] = nums[i] nums[i] = 0</code></li><li>思路二：双指针，一个指针正常走，另一个遇到非 0 的值加一，并<code>nums[j++] = nums[i]</code></li></ul><h3 id="比特位计数" tabindex="-1">比特位计数 <a class="header-anchor" href="#比特位计数" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>思路一：直接遍历，与 1 取并输出结果</li><li>思路二：dp，转移方程是<code>dp[i] = dp[i / 2] + (i &amp; 1)</code></li><li>思路三：dp，转移方程是<code>dp[i] = dp[i &amp; (i - 1)] + 1</code></li><li>思路四： <ul><li>奇数就等于前一个加一</li><li>偶数就等于<code>i &gt;&gt; 1</code></li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这道题除了第一种思路，都是用一些方法来减少计算，中间有很多计算结果，可以避免重复计算</p></div><h3 id="_4-的幂" tabindex="-1">4-的幂 <a class="header-anchor" href="#_4-的幂" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/power-of-four/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>思路一：直接循环除以 4</li><li>思路二：4 的 n 次方取模 3 为 1，4 的 n 次方*2 取模 3 为 2，所以通过取模可以得到结果</li><li>思路三：<code>n &amp; n - 1</code>并且<code>n &amp; 0xaaaaaaaa === 0</code></li></ul><h3 id="两个数组的交集" tabindex="-1">两个数组的交集 <a class="header-anchor" href="#两个数组的交集" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>思路一：暴力法+哈希表，直接<code>O(M*N)</code></li><li>思路二：先排序，再双指针比较</li></ul><h3 id="找不同" tabindex="-1">找不同 <a class="header-anchor" href="#找不同" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/find-the-difference/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>思路一： 把其中一个转成哈希表</li><li>思路二：利用位运算符的异或运算，类似<a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener noreferrer">只出现一次的数字</a></li></ul><h3 id="二进制手表" tabindex="-1">二进制手表 <a class="header-anchor" href="#二进制手表" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/binary-watch/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>枚举所有时间，即 12 小时 60 分钟，然后计算出其中二进制位为 1 的数量</li><li>枚举<code>2 ** 10</code>，取出高 4 位和低 6 位的值，分别计算是否在 12 和 60 以内</li></ul><h3 id="数字转换为十六进制数" tabindex="-1">数字转换为十六进制数 <a class="header-anchor" href="#数字转换为十六进制数" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>思路一：循环除以 16，取余数</li><li>思路二：使用位运算符</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>遇到<code>2 ** n</code>问题，首先可以考虑位运算符，提升运算效率</p></div><h3 id="排列硬币" tabindex="-1">排列硬币 <a class="header-anchor" href="#排列硬币" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/arranging-coins/" target="_blank" rel="noopener noreferrer">地址</a></p><p>思路一：直接迭代，求前 m 项和，直到前 m 项和大于 n，就输出 n - 1 思路二：二分查找</p><h3 id="找到所有数组中消失的数字" tabindex="-1">找到所有数组中消失的数字 <a class="header-anchor" href="#找到所有数组中消失的数字" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener noreferrer">地址</a></p><p>两次遍历</p><ul><li>第一次需要把原数组中需要剔除的数加上 len 的倍数</li><li>第二次只需要找出数组中小于 len 的索引并-1</li></ul><h3 id="重复的子字符串" tabindex="-1">重复的子字符串 <a class="header-anchor" href="#重复的子字符串" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>暴力法，直接挨个比对，i 从 <code>1 =&gt; n / 2</code>，<strong>比较难想到的是</strong>对比<code>s[j]</code>和<code>s[j - i]</code>，</li><li>将字符串<code>s</code>自加<code>s + s</code>，然后判断字符串<code>s</code>的第 1 个索引<code>s.indexOf(s, 1)</code>是否与<code>s</code>的长度相等，相等则返回 false</li><li><a href="https://zhuanlan.zhihu.com/p/83334559" target="_blank" rel="noopener noreferrer">KMP 算法</a></li></ul><h3 id="岛屿的周长" tabindex="-1">岛屿的周长 <a class="header-anchor" href="#岛屿的周长" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/island-perimeter/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>思路一：直接遍历，然后推倒右侧/下侧是否为 1，是的话就-2</li><li>思路二：深度优先遍历(DFS)</li></ul><h3 id="提莫攻击" tabindex="-1">提莫攻击 <a class="header-anchor" href="#提莫攻击" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/teemo-attacking/" target="_blank" rel="noopener noreferrer">地址</a></p><p>关键点在于间隔时间是否大于持续时间，如果持续时间小于间隔就加上持续时间，反之则加上时间间隔，最后再加上持续时间</p><h3 id="二叉搜索树中的众数" tabindex="-1">二叉搜索树中的众数 <a class="header-anchor" href="#二叉搜索树中的众数" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener noreferrer">地址</a></p><ul><li>思路一：直接深度优先遍历，存到 map，然后再排序，输出前几项一样大结果</li><li>思路二：中序遍历，然后记录连续的数，做一定判断</li><li>思路三： Morris 中序遍历</li></ul><p><strong>Morris 核心思路</strong></p><ul><li>如果当前节点没有左子树，则遍历这个点，然后跳转到当前节点的右子树。</li><li>如果当前节点有左子树，那么它的前驱节点一定在左子树上，我们可以在左子树上一直向右行走，找到当前点的前驱节点。 <ul><li>如果前驱节点没有右子树，就将前驱节点的 right 指针指向当前节点。这一步是为了在遍历完前驱节点后能找到前驱节点的后继，也就是当前节点。</li><li>如果前驱节点的右子树为当前节点，说明前驱节点已经被遍历过并被修改了 right 指针，这个时候我们重新将前驱的右孩子设置为空，遍历当前的点，然后跳转到当前节点的右子树。</li></ul></li></ul><div class="language-js"><pre><code><span class="token keyword">while</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 左节点不存在，直接处理当前节点，然后指针移到右节点</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">update</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    node <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token keyword">continue</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 左节点存在，将pre指针指向左节点</span>
  pre <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token comment">// 一直向右走，找到前驱节点</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> pre<span class="token punctuation">.</span>right <span class="token operator">!==</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 如果前驱节点没有右节点，就把让前驱的right节点指向当前节点</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pre<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pre<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">;</span>
    node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 恢复设置的节点</span>
    pre<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token function">update</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    node <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>遇到二叉搜索数，记得使用中序遍历，遍历的结果是一个有序数组</p></div><h2 id="easy-1" tabindex="-1">easy <a class="header-anchor" href="#easy-1" aria-hidden="true">#</a></h2><h3 id="格雷编码" tabindex="-1">格雷编码 <a class="header-anchor" href="#格雷编码" aria-hidden="true">#</a></h3><p><a href="https://leetcode-cn.com/problems/gray-code/" target="_blank" rel="noopener noreferrer">地址</a></p><p>思路一：加一 + 逆序 00 01 11 10 =&gt; 100 101 111 110 =&gt; 110 111 101 100 思路二：右移 + 与原数去亦或 110 =&gt; 111 =&gt; 001</p></div></div></main></div></div><footer class="px-5 sm:px-7 md:px-10 text-center text-gray-400 text-sm my-5"><div class="text-center mb-5"><!--[--><a href="https://juejin.cn/user/1838039174496135" target="_blank" class="unstyled transition-opacity inline-block opacity-70 hover:opacity-100 mr-5" title="Juejin: Recovery"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" width="24" height="24" version="1.1" style="shape-rendering:geometricPrecision;text-rendering:geometricPrecision;image-rendering:optimizeQuality;fill-rule:evenodd;clip-rule:evenodd;" viewbox="0 0 500 500" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="图层_x0020_1"><metadata id="CorelCorpID_0Corel-Layer"></metadata><circle cx="250" cy="250" r="250" fill="#006CFF"></circle><path id="Fill-1-Copy" class="fil1" d="M285 138l-31 -24 -33 25 -2 2 35 27 34 -27 -3 -3zm119 95l-150 116 -151 -116 -22 17 173 134 173 -134 -23 -17zm-150 9l-82 -63 -23 17 105 81 104 -81 -22 -17 -82 63z" fill="#fff"></path></g></svg></a><a href="https://github.com/cq360767996" target="_blank" class="unstyled transition-opacity inline-block opacity-70 hover:opacity-100 mr-5" title="Github: cq360767996"><svg role="img" viewbox="0 0 24 24" width="24" height="24" xmlns="http://www.w3.org/2000/svg" fill="#059669"><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg></a><a href="https://gitee.com/cq360" target="_blank" class="unstyled transition-opacity inline-block opacity-70 hover:opacity-100 mr-5" title="Gitee: cq360"><svg width="24" height="24" viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="1830"><path d="M512 1024C230.4 1024 0 793.6 0 512S230.4 0 512 0s512 230.4 512 512-230.4 512-512 512z m259.2-569.6H480c-12.8 0-25.6 12.8-25.6 25.6v64c0 12.8 12.8 25.6 25.6 25.6h176c12.8 0 25.6 12.8 25.6 25.6v12.8c0 41.6-35.2 76.8-76.8 76.8h-240c-12.8 0-25.6-12.8-25.6-25.6V416c0-41.6 35.2-76.8 76.8-76.8h355.2c12.8 0 25.6-12.8 25.6-25.6v-64c0-12.8-12.8-25.6-25.6-25.6H416c-105.6 0-188.8 86.4-188.8 188.8V768c0 12.8 12.8 25.6 25.6 25.6h374.4c92.8 0 169.6-76.8 169.6-169.6v-144c0-12.8-12.8-25.6-25.6-25.6z" fill="#c71d24" p-id="1831"></path></svg></a><!--]--></div><p class="mb-3">© 2021 Recovery, All rights reserved.</p></footer><!----><!----><div class="bg-white fixed top-1/2 transform -translate-y-1/2 right-10 max-h-120 max-w-60 flex flex-col &lt;lg:hidden"><h1 class="p-2 text-xl border-b py-2 mb-2">目录</h1><ul class="px-2 flex-1 overflow-y-auto"><!--[--><li title="easy" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:0rem;" tabindex="-1"><a href="#easy">easy</a></li><li title="罗马文字解析" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#罗马文字解析">罗马文字解析</a></li><li title="最长公共前缀" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#最长公共前缀">最长公共前缀</a></li><li title="有效的括号" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#有效的括号">有效的括号</a></li><li title="合并两个有序链表" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#合并两个有序链表">合并两个有序链表</a></li><li title="删除有序数组中的重复项" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#删除有序数组中的重复项">删除有序数组中的重复项</a></li><li title="实现 strStr()" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#实现-strstr">实现 strStr()</a></li><li title="外观数列" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#外观数列">外观数列</a></li><li title="最大子序和" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#最大子序和">最大子序和</a></li><li title="最后一个单词的长度" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#最后一个单词的长度">最后一个单词的长度</a></li><li title="x 的平方根" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#x-的平方根">x 的平方根</a></li><li title="合并两个有序数组" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#合并两个有序数组">合并两个有序数组</a></li><li title="只出现一次的数字" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#只出现一次的数字">只出现一次的数字</a></li><li title="相交链表" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#相交链表">相交链表</a></li><li title="多数元素" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#多数元素">多数元素</a></li><li title="阶乘后的零" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#阶乘后的零">阶乘后的零</a></li><li title="颠倒二进制位" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#颠倒二进制位">颠倒二进制位</a></li><li title="快乐数" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#快乐数">快乐数</a></li><li title="计算质数" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#计算质数">计算质数</a></li><li title="反转链表" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#反转链表">反转链表</a></li><li title="汇总区间" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#汇总区间">汇总区间</a></li><li title="2 的幂" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#_2-的幂">2 的幂</a></li><li title="回文链表" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#回文链表">回文链表</a></li><li title="二叉搜索树的最近公共祖先" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#二叉搜索树的最近公共祖先">二叉搜索树的最近公共祖先</a></li><li title="各数相加" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#各数相加">各数相加</a></li><li title="丑数" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#丑数">丑数</a></li><li title="丢失的数字" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#丢失的数字">丢失的数字</a></li><li title="第一个错误的版本" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#第一个错误的版本">第一个错误的版本</a></li><li title="移动零" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#移动零">移动零</a></li><li title="比特位计数" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#比特位计数">比特位计数</a></li><li title="4-的幂" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#_4-的幂">4-的幂</a></li><li title="两个数组的交集" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#两个数组的交集">两个数组的交集</a></li><li title="找不同" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#找不同">找不同</a></li><li title="二进制手表" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#二进制手表">二进制手表</a></li><li title="数字转换为十六进制数" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#数字转换为十六进制数">数字转换为十六进制数</a></li><li title="排列硬币" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#排列硬币">排列硬币</a></li><li title="找到所有数组中消失的数字" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#找到所有数组中消失的数字">找到所有数组中消失的数字</a></li><li title="重复的子字符串" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#重复的子字符串">重复的子字符串</a></li><li title="岛屿的周长" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#岛屿的周长">岛屿的周长</a></li><li title="提莫攻击" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#提莫攻击">提莫攻击</a></li><li title="二叉搜索树中的众数" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#二叉搜索树中的众数">二叉搜索树中的众数</a></li><li title="easy" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:0rem;" tabindex="-1"><a href="#easy-1">easy</a></li><li title="格雷编码" class="text-lg overflow-ellipsis whitespace-nowrap overflow-hidden leading-loose" style="padding-left:1rem;" tabindex="-1"><a href="#格雷编码">格雷编码</a></li><!--]--></ul></div><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"readme.md\":\"11d981ec\",\"about_index.md\":\"9c0fbf3a\",\"blog_css_居中方案.md\":\"29424092\",\"blog_interview_index.md\":\"45c364a7\",\"blog_js_js模块化.md\":\"b0117550\",\"blog_js_代码规范.md\":\"c7f00b1b\",\"blog_js_前端性能优化.md\":\"52cf8bde\",\"blog_js_手写promise.md\":\"4beada86\",\"blog_js_手写系列.md\":\"a709f2a6\",\"blog_js_浏览器常见问题.md\":\"8ba8df15\",\"blog_js_闭包详解.md\":\"4058efc9\",\"blog_leetcode_index.md\":\"b587bdc7\",\"blog_ts_index.md\":\"b0a695eb\",\"blog_vue_基于el-tree的虚拟滚动.md\":\"03e1560f\",\"blog_webpack_webpack优化.md\":\"70600524\",\"contact_index.md\":\"efadebdd\",\"index.md\":\"adcc2b95\"}")</script>
    <script type="module" async src="/assets/app.853852ae.js"></script>
    
  </body>
</html>