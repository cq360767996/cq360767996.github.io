import{o as n,c as s,d as a}from"./app.5bf5680f.js";const p='{"title":"js模块化","description":"","frontmatter":{"title":"js模块化","date":"2020-09-04T00:00:00.000Z","sidebar":"auto","categories":["js"],"tags":["js"]},"headers":[{"level":2,"title":"前端模块化方案","slug":"前端模块化方案"},{"level":3,"title":"解决方案","slug":"解决方案"},{"level":2,"title":"以 script 文件为模块","slug":"以-script-文件为模块"},{"level":2,"title":"立即执行函数","slug":"立即执行函数"},{"level":2,"title":"AMD(Asynchronous Module Definition)","slug":"amd-asynchronous-module-definition"},{"level":2,"title":"CMD(Common Module Definition)","slug":"cmd-common-module-definition"},{"level":3,"title":"define define(\'a\')","slug":"define-define-a"},{"level":3,"title":"define define(factory)","slug":"define-define-factory"},{"level":3,"title":"define 接受多个参数 define(id?, deps?, factory)","slug":"define-接受多个参数-define-id-deps-factory"},{"level":3,"title":"define.cmd","slug":"define-cmd"},{"level":3,"title":"require(id)","slug":"require-id"},{"level":3,"title":"exports","slug":"exports"},{"level":3,"title":"module","slug":"module"},{"level":2,"title":"CommonJS","slug":"commonjs"},{"level":3,"title":"Module 函数","slug":"module-函数"},{"level":3,"title":"手动实现 MyModule 类","slug":"手动实现-mymodule-类"},{"level":3,"title":"循环引用","slug":"循环引用"},{"level":2,"title":"ESModule","slug":"esmodule"},{"level":2,"title":"webpack","slug":"webpack"},{"level":2,"title":"参考文档","slug":"参考文档"}],"relativePath":"blog/js/js模块化.md","lastUpdated":1622946169855}',t={},o=a('<h2 id="前端模块化方案"><a class="header-anchor" href="#前端模块化方案" aria-hidden="true">#</a> 前端模块化方案</h2><p><code>javascript</code>在发展之初，并未考虑到模块化，Brendan Eich 仅仅花了 10 天就设计出了这款语言，目的就是为了能让网页完成一些简单的操作，比如用户有没有填写表单之类的，但是随着时代的发展，浏览器的地位越来越重要，语言本身暴露出来的问题越来越多，其中较为头疼的就是模块化。不能模块化的问题有哪些：</p><ul><li>充斥着各种全局变量，在使用完不进行回收的话，会占用较多内存</li><li>全局变量相互牵制，命名容易出现重名导致未知问题</li></ul><h3 id="解决方案"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h3><ul><li>以 script 文件为模块</li><li>立即执行函数</li><li>AMD(Asynchronous Module Definition)</li><li>CMD(Common Module Definition)</li><li>CommonJS</li><li>ESModule</li><li>webpack</li></ul><h2 id="以-script-文件为模块"><a class="header-anchor" href="#以-script-文件为模块" aria-hidden="true">#</a> 以 script 文件为模块</h2><p>优点：</p><ul><li>不用将所有代码写在一个文件里面</li><li>可以复用一些代码</li></ul><p>缺点：全局变量混乱的问题并未解决</p><h2 id="立即执行函数"><a class="header-anchor" href="#立即执行函数" aria-hidden="true">#</a> 立即执行函数</h2><p>因为 js 每一个函数都拥有属于自己的执行上下文，所以可以利用这个特点，创建一个封闭的环境，来隔绝环境内的变量，内部的变量可以通过挂载到 window 上来进行导出</p><div class="language-js"><pre><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">window</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  window<span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错 a is not defined</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>\n</code></pre></div><h2 id="amd-asynchronous-module-definition"><a class="header-anchor" href="#amd-asynchronous-module-definition" aria-hidden="true">#</a> AMD(Asynchronous Module Definition)</h2><p>异步模块定义，是用来实现模块的异步加载，合理管理模块之间的依赖性。requirejs 遵循一个原则：一个文件就是一个模块，它推崇的是<strong>依赖前置</strong>，即在 require 的时候就需要加载对应的模块，核心函数有三个：</p><ul><li>require</li><li>define</li><li>require.config</li></ul><p>当你需要引入一个模块的时候，可以这么写：</p><div class="language-js"><pre><code><span class="token comment">// 第一个参数为一个数组，路径是以入口文件相对的路径，在本模块依赖的其他模块的路径</span>\n<span class="token comment">// 第二个参数为一个回调函数，回调函数的参数分别是数组里面的模块的一个引用</span>\n<span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;moduleA&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;moduleB&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">moduleA<span class="token punctuation">,</span> moduleB</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// moduleA 和 moduleB 的引用</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p>如果需要定义一个模块，可以这么写：</p><div class="language-js"><pre><code><span class="token comment">// 第一个参数为一个数组，和require一样</span>\n<span class="token comment">// 第二个参数为一个回调函数，和require一样，区别在于定义模块的时候需要有一个返回值用于模块的导出</span>\n<span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;moduleA&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">moduleA</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> exports <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> exports<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p>如果需要对 require 进行配置，可以使用 require.config 函数，require.config 函数接受一个对象作为参数。</p><div class="language-js"><pre><code>require<span class="token punctuation">.</span><span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token comment">// 修改入口文件的相对路径./为./lib</span>\n  baseUrl<span class="token operator">:</span> <span class="token string">&#39;lib&#39;</span><span class="token punctuation">,</span>\n  <span class="token comment">// 默认引入一些模块</span>\n  paths<span class="token operator">:</span> <span class="token punctuation">{</span>\n    jquery<span class="token operator">:</span> <span class="token string">&#39;jquery.min&#39;</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token comment">// 对于不基于amd规范的模块一个垫片</span>\n  <span class="token comment">// deps: 是该模块的依赖</span>\n  <span class="token comment">// exports: 输出的变量名，表明模块外部调用时的名称</span>\n  shim<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token string">&#39;jquery.scroll&#39;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      deps<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;jquery&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n      exports<span class="token operator">:</span> <span class="token string">&#39;jQuery.fn.scroll&#39;</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><h2 id="cmd-common-module-definition"><a class="header-anchor" href="#cmd-common-module-definition" aria-hidden="true">#</a> CMD(Common Module Definition)</h2><p>CMD 规范最具代表的框架就是 seajs，它推崇<strong>依赖就近</strong>，既需要使用的时候才会去加载依赖，全局只暴露一个函数 define，个人理解它是 requirejs 衍生出来的一个规范，或者说是对 requirejs 的一个优化，define 可以接受一个回调函数也可以接受一个变量。</p><h3 id="define-define-a"><a class="header-anchor" href="#define-define-a" aria-hidden="true">#</a> define <code>define(&#39;a&#39;)</code></h3><p>如果是一个变量，表示模块导出之后就是该变量的值。</p><h3 id="define-define-factory"><a class="header-anchor" href="#define-define-factory" aria-hidden="true">#</a> define <code>define(factory)</code></h3><p>如果为一个函数，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。</p><div class="language-js"><pre><code><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 模块代码</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><h3 id="define-接受多个参数-define-id-deps-factory"><a class="header-anchor" href="#define-接受多个参数-define-id-deps-factory" aria-hidden="true">#</a> define 接受多个参数 <code>define(id?, deps?, factory)</code></h3><ul><li>id: 模块标识（可省略）</li><li>deps: 模块依赖（可省略）</li><li>factory: 模块的构造方法</li></ul><p>**注意：**带 id 和 deps 参数的 define 用法不属于 CMD 规范，而属于 Modules/Transport 规范。</p><h3 id="define-cmd"><a class="header-anchor" href="#define-cmd" aria-hidden="true">#</a> define.cmd</h3><p>用来判断当前页面是否有 CMD 模块加载器，是一个空对象</p><div class="language-js"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> define <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span> <span class="token operator">&amp;&amp;</span> define<span class="token punctuation">.</span>cmd<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 有 Sea.js 等 CMD 模块加载器存在</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="require-id"><a class="header-anchor" href="#require-id" aria-hidden="true">#</a> require(id)</h3><p>require 是 factory 的第一个参数，他接受一个<a href="https://github.com/seajs/seajs/issues/258" target="_blank" rel="noopener noreferrer">模块标识</a>作为入参，模块标识必须遵循以下规范：</p><ul><li>一个模块标识由斜线（/）分隔的多项组成。</li><li>每一项必须是小驼峰字符串、 . 或 .. 。</li><li>模块标识可以不包含文件后缀名，比如 .js 。</li><li>模块标识可以是 相对 或 顶级 标识。如果第一项是 . 或 ..，则该模块标识是相对标识。</li><li>顶级标识根据模块系统的基础路径来解析。</li><li>相对标识相对 require 所在模块的路径来解析。</li></ul><div class="language-js"><pre><code><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exports</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 引入模块表示为&#39;./a&#39;的模块，就近依赖不需要在执行define函数中声明所需的依赖</span>\n  <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./a&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><h3 id="exports"><a class="header-anchor" href="#exports" aria-hidden="true">#</a> exports</h3><p>exports 是 factory 函数的第二个参数，它是一个对象，是用来导出模块的，需要注意的是 exports 只是对 module.exports 的一个引用，如果直接对 exports 进行赋值，是无法进行导出的。</p><div class="language-js"><pre><code><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exports</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 导出{a: &#39;a&#39;}对象</span>\n  exports<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// exports = module.exports =&gt; exports = &#39;a&#39;</span>\n  <span class="token comment">// 引用失效，无法导出</span>\n  exports <span class="token operator">=</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// 或者可以直接return，也可以正常导出</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><h3 id="module"><a class="header-anchor" href="#module" aria-hidden="true">#</a> module</h3><p>module 是 factory 函数的第三个参数，他是一个对象，里面报错了当前模块的 id、url、dependencies、exports</p><ul><li>id: 模块唯一标识</li><li>url: 模块的绝对路径</li><li>dependencies: 是一个数组，当前模块的依赖</li><li>exports: 对外导出的内容</li></ul><h2 id="commonjs"><a class="header-anchor" href="#commonjs" aria-hidden="true">#</a> CommonJS</h2><p>CommonJS 是 node 所采用的模块管理机制，每个文件算一个模块，并且拥有独立的作用域，形成自己独立的执行上下文，其实现思路是基于 amd 和 cmd 规范的。而且不适用浏览器，因为他的实现高度依赖 node 的文件模块。总结一下就是：</p><ul><li>每个文件是一个模块，拥有独立作用域。</li><li>依赖 node 的原生模块，不适用于浏览器。</li><li>模块是同步加载，执行顺序按照代码顺序进行。</li><li>对依赖的模块会进行缓存，第一次引入模块的时候，会执行模块内代码，缓存之后直接取导出的结果，不会再执行。</li></ul><div class="language-js"><pre><code><span class="token comment">// add.js</span>\n<span class="token comment">// 导出一个函数模块</span>\nmodule<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// main.js</span>\n<span class="token comment">// 引入add模块</span>\n<span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./add&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> sum <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>\n</code></pre></div><p><strong>注意：</strong> module 和 require 并不是全局函数，暴露到全局的只有一个函数 Module。</p><h3 id="module-函数"><a class="header-anchor" href="#module-函数" aria-hidden="true">#</a> Module 函数</h3><p>node 内部提供一个 Module 函数，所有的模块都是 Module 的实例。上文所说的 module 就是 Module 的一个实例，require 函数只是 Module 的一个沙箱里面一个参数，最终会执行 Mudule 的 require 函数。</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Module</span><span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span> <span class="token comment">// 这个id其实就是我们require的路径</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>path <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">dirname</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// path是Node.js内置模块，用它来获取传入参数对应的文件夹路径</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 导出的东西放这里，初始化为空对象</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>filename <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 模块对应的文件名</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>loaded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// loaded用来标识当前模块是否已经加载</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>可以看到 Module 只是一个普通的函数，接下来我们来实现一个属于自己的 Module 类</p><h3 id="手动实现-mymodule-类"><a class="header-anchor" href="#手动实现-mymodule-类" aria-hidden="true">#</a> 手动实现 MyModule 类</h3><p>都 0202 年了，就直接上 class 吧，ps: 虽然<a href="https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js" target="_blank" rel="noopener noreferrer">源代码</a>里面用的是 function 的写法。</p><h4 id="构造一个-mymodule-类"><a class="header-anchor" href="#构造一个-mymodule-类" aria-hidden="true">#</a> 构造一个 MyModule 类</h4><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">MyModule</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>path <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">dirname</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>exports <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>filename <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>loaded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>注意：构造函数里的 path 是需要引入的，是 node 原生的 path 模块</p></div><h4 id="添加实例方法-require"><a class="header-anchor" href="#添加实例方法-require" aria-hidden="true">#</a> 添加实例方法 require</h4><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">MyModule</span> <span class="token punctuation">{</span>\n  <span class="token function">require</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 交给静态方法来处理</span>\n    <span class="token keyword">return</span> MyModule<span class="token punctuation">.</span><span class="token function">_load</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">static</span> <span class="token function">_load</span><span class="token punctuation">(</span><span class="token parameter">request</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 此处为require的真正实现</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="mymodule-load"><a class="header-anchor" href="#mymodule-load" aria-hidden="true">#</a> MyModule._load</h4><p>该方法主要用来两件事情：</p><ul><li>查看缓存中是否存在当前模块，有的话就直接读取缓存。</li><li>没有缓存的话，就新建一个 MyModule 实例来加载对应模块，并且写入缓存。</li></ul><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">MyModule</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 创建一个没有继承原型的空对象用于缓存模块</span>\n  <span class="token keyword">static</span> _cache <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">static</span> <span class="token function">_load</span><span class="token punctuation">(</span><span class="token parameter">request</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 将request解析对应的路径</span>\n    <span class="token keyword">const</span> filename <span class="token operator">=</span> MyModule<span class="token punctuation">.</span><span class="token function">_resolveFilename</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">const</span> cacheModule <span class="token operator">=</span> MyModule<span class="token punctuation">.</span>_cache<span class="token punctuation">[</span>filename<span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 如果存在缓存，直接从缓存读取</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheModule <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> cacheModule<span class="token punctuation">.</span>exports<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 如果不存在，就新建一个MyModule实例</span>\n    <span class="token keyword">const</span> module <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyModule</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 写入缓存</span>\n    MyModule<span class="token punctuation">.</span>_cache<span class="token punctuation">[</span>filename<span class="token punctuation">]</span> <span class="token operator">=</span> module<span class="token punctuation">;</span>\n\n    <span class="token comment">// 加载模块，该方法是一个实例方法，用来加载一个新模块</span>\n    module<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">return</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="mymodule-resolvefilename"><a class="header-anchor" href="#mymodule-resolvefilename" aria-hidden="true">#</a> MyModule._resolveFilename</h4><ul><li>先获取文件的绝对路径</li><li>获取文件后缀名</li><li>如果没有后缀就尝试加上后缀，比如.js .json 等等</li><li>加上扩展名可以找到对应文件的时候，调用 MyModule._extensions 里面对应的方法来处理对应的扩展</li></ul><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">MyModule</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 对应扩展的处理方法（策略模式）</span>\n  <span class="token keyword">static</span> _extensions <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token string">&#39;.js&#39;</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">module<span class="token punctuation">,</span> filename</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token string">&#39;.json&#39;</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">module<span class="token punctuation">,</span> filename</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">static</span> <span class="token function">_resolveFilename</span><span class="token punctuation">(</span><span class="token parameter">request</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 获取绝对路径</span>\n    <span class="token keyword">const</span> filename <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 获取文件后缀名</span>\n    <span class="token keyword">const</span> extname <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">extname</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 如果没有文件后缀，就尝试加上.js和.json</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>extname<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>MyModule<span class="token punctuation">.</span>_extensions<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">const</span> currentPath <span class="token operator">=</span> filename <span class="token operator">+</span> key<span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>fs<span class="token punctuation">.</span><span class="token function">existsSync</span><span class="token punctuation">(</span>currentPath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword">return</span> currentPath<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> filename<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="mymodule-prototype-load"><a class="header-anchor" href="#mymodule-prototype-load" aria-hidden="true">#</a> MyModule.prototype.load</h4><p>该方法用来加载一个新的模块，找到对应的扩展名，调用对应的方法。</p><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">MyModule</span> <span class="token punctuation">{</span>\n  <span class="token keyword">static</span> _extensions <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token string">&#39;.js&#39;</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">module<span class="token punctuation">,</span> filename</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      <span class="token comment">// js扩展的实现</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token string">&#39;.json&#39;</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">module<span class="token punctuation">,</span> filename</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> content <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">&#39;utf8&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token function">load</span><span class="token punctuation">(</span><span class="token parameter">filename</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 获取找到的文件的扩展</span>\n    <span class="token keyword">const</span> ext <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">extname</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 使用策略模式来调用对应扩展的方法</span>\n    MyModule<span class="token punctuation">.</span>_extensions<span class="token punctuation">[</span>ext<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 打上已加载的标记</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>loaded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="mymodule-extensions-js"><a class="header-anchor" href="#mymodule-extensions-js" aria-hidden="true">#</a> MyModule._extensions[&#39;.js&#39;]</h4><p>加载.js 文件的时候，需要先执行一次，执行的时候，避免污染全局变量，需要将其包裹在一个独立的执行上下文</p><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">MyModule</span> <span class="token punctuation">{</span>\n  <span class="token keyword">static</span> _extensions <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token string">&#39;.js&#39;</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">module<span class="token punctuation">,</span> filename</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> content <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">&#39;utf8&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token comment">// 交给实例方法compile处理</span>\n      module<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">static</span> _wrapper <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;(function (exports, require, module, __filename, __dirname) { &#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;\\n});&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// 包裹一层匿名函数</span>\n  <span class="token keyword">static</span> <span class="token function">_wrap</span><span class="token punctuation">(</span><span class="token parameter">script</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> MyModule<span class="token punctuation">.</span>_wrapper<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> script <span class="token operator">+</span> MyModule<span class="token punctuation">.</span>_wrapper<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">compile</span><span class="token punctuation">(</span><span class="token parameter">content<span class="token punctuation">,</span> filename</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 获取包裹之后的函数字符串</span>\n    <span class="token keyword">const</span> wrapper <span class="token operator">=</span> MyModule<span class="token punctuation">.</span><span class="token function">_wrap</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// vm是V8虚拟机的沙盒模块，runInThisContext可以将一个字符串转换为一个函数</span>\n    <span class="token keyword">const</span> compiledWrapper <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">runInThisContext</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n      filename<span class="token punctuation">,</span>\n      lineOffset<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n      displayErrors<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 获取模块所在的文件夹的绝对路径</span>\n    <span class="token keyword">const</span> dirname <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">dirname</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 这里就是准备我们在模块内可以使用的一些变量和函数</span>\n    <span class="token comment">// exports: 对module.exports的引用</span>\n    <span class="token comment">// require: 加载函数的入口</span>\n    <span class="token comment">// this: 此处的this指的是该模块的实例，即module</span>\n    <span class="token comment">// filename: 对应文件的绝对路径 __filename</span>\n    <span class="token comment">// dirname: 对应文件的所处文件夹的绝对路径 __dirname</span>\n    <span class="token function">compiledWrapper</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>exports<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>exports<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>require<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> dirname<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="循环引用"><a class="header-anchor" href="#循环引用" aria-hidden="true">#</a> 循环引用</h3><p>至此，一个属于我们自己的 MyModule 类构造完成，但是假象一下，你在 a.js 中<code>require(&#39;./b.js&#39;)</code>，然后再在 b.js 中<code>require(&#39;./a.js&#39;)</code>，是不是会有一种循环引用的情况？</p><div class="language-js"><pre><code><span class="token comment">// a.js</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;a start&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./b&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;在 a 中，b = %j&#39;</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token string">&#39;aa&#39;</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;a end&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><div class="language-js"><pre><code><span class="token comment">// b.js</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;b start&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./a&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;在 b 中，a = %j&#39;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token string">&#39;bb&#39;</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;b end&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><div class="language-js"><pre><code>main<span class="token punctuation">.</span>js<span class="token punctuation">;</span>\n<span class="token keyword">const</span> myModule <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyModule</span><span class="token punctuation">(</span><span class="token string">&#39;./main&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> a <span class="token operator">=</span> myModule<span class="token punctuation">.</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./a&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> b <span class="token operator">=</span> myModule<span class="token punctuation">.</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./b&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p>其输出结果如下：</p><ul><li>a start</li><li>b start</li><li>在 b 中，a = &quot;a&quot;</li><li>b end</li><li>在 a 中，b = &quot;bb&quot;</li><li>a end</li><li>aa</li><li>bb<div class="tip custom-block"><p class="custom-block-title">TIP</p><p>可以看到在 b 中 require 的 a 为&quot;a&quot;，在 a 中的 require b 的时候不会再去执行 b 模块的代码，因为之前已经加载过了，所以直接读取的缓存，在_load 里面是有做处理的。</p></div></li></ul><h2 id="esmodule"><a class="header-anchor" href="#esmodule" aria-hidden="true">#</a> ESModule</h2><p>ESModule 解析模块分三步走：</p><ul><li>Construction(构造) <ul><li>找出包含此模块的下载地址（模块解析）</li><li>从 url 或者文件系统中请求该文件</li><li>将该文件转换为一条模块记录</li></ul></li><li>Instantiation(实例化) <ul><li>js 引擎创建一个 module environment record(模块环境记录)，个人理解是用来装模块变量引用的</li><li>确定每一个变量名，并不会进行传值，但是使用 function 的话会就进行传值，类似于执行上下文的初始化阶段</li><li>确定每个 export 和 import 的引用指向同一块内存地址（所谓的动态绑定）</li></ul></li><li>Evaluation(执行) <ul><li>将所有模块变量填充到内存里面</li><li>并写入缓存，防止循环引用</li></ul></li></ul><h2 id="webpack"><a class="header-anchor" href="#webpack" aria-hidden="true">#</a> webpack</h2><p>大家写代码的时候可能会遇到一些这样子的写法：</p><div class="language-js"><pre><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./a&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>default<span class="token punctuation">;</span>\n</code></pre></div><p>这是因为 webpack 自己实现了一套模块化加载机制，兼容 ESModule 和 CommonJS 规范，你可以通过 import/export 来管理模块，也可以通过 module.exports 来管理模块。在最终加载的时候都会被替换成<code>__webpack_require__</code>，所以当你以 ESModule 导出一个模块的时候，再用 CommonJS 来引入的时候就会出现这种问题。</p><div class="language-js"><pre><code><span class="token comment">// a.js</span>\n<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> a<span class="token punctuation">;</span>\n</code></pre></div><div class="language-js"><pre><code><span class="token comment">// main.js 等价于 import a from &#39;a.js&#39;;</span>\n<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;a.js&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>default<span class="token punctuation">;</span>\n</code></pre></div><h2 id="参考文档"><a class="header-anchor" href="#参考文档" aria-hidden="true">#</a> 参考文档</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="noopener noreferrer">Javascript 模块化编程（三）：require.js 的用法</a></li><li><a href="https://seajs.github.io/seajs/docs/#intro" target="_blank" rel="noopener noreferrer">seajs 官方文档</a></li><li><a href="https://juejin.im/post/6844904029454073864#heading-8" target="_blank" rel="noopener noreferrer">JavaScript 模块化规范（CommonJs AMD CMD UMD ES6）</a></li><li><a href="https://javascript.ruanyifeng.com/nodejs/module.html#toc0" target="_blank" rel="noopener noreferrer">JavaScript 标准参考教程（alpha）</a></li><li><a href="https://juejin.im/post/6866973719634542606#heading-16" target="_blank" rel="noopener noreferrer">深入 Node.js 的模块加载机制，手写 require 函数</a></li><li><a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" target="_blank" rel="noopener noreferrer">ES modules: A cartoon deep-dive</a></li></ul>',91);t.render=function(a,p,t,e,c,l){return n(),s("div",null,[o])};export default t;export{p as __pageData};
